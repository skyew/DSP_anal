---
title: "Dynamic Soil Property - Data Analysis"
author: 'Skye Wills'
output: html_document
---  


If you are new to R; consider an introductory session such as Statistics for Soil Survey
------------------------------

### Required packages 
The first time you use this uncomment next line (remove the '#' and install these packages)

```{r prepPackages, echo=F, error=F}

#install.packages(c("fastmatch", "ggplot2", "plyr","Rcpp", "RColorBrewer", "lme4", "lattice", "maps", "aqp", "soilDB"))
library(fastmatch)
library(ggplot2)
library(Rcpp)
library(plyr)
library(RColorBrewer)
library(lme4)
library(lattice)
library(maps)
library(aqp)
library(soilDB)
```

## Inputs and Outputs
-------------
This portion may need to be modified with updated info for your project 

file locations - alter path inside quotations, note that the backslash is used

```{r fileLocations}
#input files - Excel spreadsheets can be saved as individual csv files 
#alternatively use the 'load data' GUI in R or Rstudio

#data

dsp <- read.csv("C:/Users/skye.wills/Documents/DSP/DSP_data/dsp_data.csv")

#labels
dsp_labels <- read.csv("C:/Users/skye.wills/Documents/DSP/DSP_data/dsp_label.csv")

#location (folder) for output files (change to whatever you like)
#after running analysis below check this folder for results

out.loc <- "~/DSP/DSP_data/output"
```


#### List of available DSP project names
Followed by number of samples in each project
```{r project}
table(dsp$Name)

#Alter this statement to select the project of interest "alter project code inside quotations"

PROJECT<-"ID_Threebear"

out.loc <- paste0("~/DSP/DSP_data/output/", PROJECT, "/")
 
```

#### List of User Pedon IDs in Project
All pedons in this project - can be used in NASIS queries/reports
```{r pedons}

pr <- which(dsp$Name==PROJECT)
dsp_pr <- dsp[pr,]


#retrieve userpedon id's and output for use in sql
dsp_userid <- dsp_pr$UserPedonID
qq <- toString(shQuote(dsp_userid))
ql <- paste(qq, collapse=",")
writeChar(ql, con= paste0(out.loc,"userid.txt" ))
          
```

#### Fields used for comparison and data analysis
- typically test for mgmt or condition effect (typically MGMT)
- account for sampling scheme (plots)
```{r compare}
COMPARE<-"COND"

#label for comparison made - usually management system or state phase or condition
x_label <- "Management System"

#stratify data by spatial collection distribution (use unique plot id)
PLOT<-"Plot.ID"

#Plot numbers - plot numbers, are not unique across COND; but are shorter labels
PLOT_NO <- "Plot"
```

### Comparable Layers
It is helpful to group horizons into similar layers for analysis. 
Look at the dsp_data file, you may want relabel the comp_layer for your project.
after grouping horizons appropriately, save as a csv file and reload the data
  - an example is given, this will need to be updated for each project

```{r compLayer}

#description of each comparable layer (comp_layer) - all layers/samples will be labeled based on this
comp_1 <- "O and A horizons"
comp_2 <- "other"
comp_3 <- "Parent Material 1 - E and B"
comp_4 <- "Parent Material 2 - E and B"

#if needed edit comparable layer and upload data again
dsp <- read.csv("~/DSP/DSP_data/dsp_data.csv")

```

#### Properties

###### Property Standardization - bulk density
Create standardized properties when multiple methods are used, such as bulk density
  -change rank of methods to alter the way multiple methods are analyzed
  -for this example core bulk density was favored because it was done on nearly all samples
```{r propStd}

# select project of interest
pr <- which(dsp$Name==PROJECT)
dsp_pr <- dsp[pr,]

#total number of rows (layers in project)
nrow(dsp_pr)

# row count for each type of bulk density
apply(dsp_pr[, grep("^BD", names(dsp_pr))], 2, function(x) length(which(!is.na(x))))

#name of new combined bulk density column
bd <- "BulkDensity"

#Order of bulk density selection - change order if desired
bd_1 <- "BD_core_fld"
bd_2 <- "BD_clod_13"
bd_3 <- "BD_compcav"
bd_4 <- "BD_recon13"
bd_5 <- "BD_other"
```


###### Properties of Interest
--------
This will change the graphs and tests you see immediately.Output for all tests will be exported to the designated output location.
  
```{r propSelect}
#properties of interest (use anal code from dsp labels, between " ")
A<-"SOC"
B<-"Clay"
C<-"BulkDensity"
D<-"AggStab"
```


# Analysis
**************
  
**This portion *shouldn't* require further entry to run**

### Data Prep
------------------
```{r dataPrep}
#create new data element that combines all bulk density methods

dsp_pr$bd <- as.numeric(
  ifelse(!is.na(dsp_pr[,bd_1]), dsp_pr[,bd_1], 
    ifelse(!is.na(dsp_pr[,bd_2]), dsp_pr[,bd_2],
      ifelse(!is.na(dsp_pr[,bd_3]), dsp_pr[,bd_3],
          ifelse(!is.na(dsp_pr[,bd_4]), dsp_pr[,bd_4],
              dsp_pr[,bd_5])
  ))))

#rename with assigned name from previous section
names(dsp_pr)[names(dsp_pr)=="bd"] <- bd

#new field with source of bd data
dsp_pr$bd_source <-  ifelse(!is.na(dsp_pr[,bd_1]), bd_1, 
    ifelse(!is.na(dsp_or[,bd_2]), bd_2,
      ifelse(!is.na(dsp_pr[,bd_3]), bd_3,
          ifelse(!is.na(dsp_pr[,bd_4]), bd_4,
              bd_5))))

table(dsp_pr$bd_source)
summary(dsp_pr$BulkDensity)

#change na's to zero for Calcium carbonate
dsp$CaCarb[is.na(dsp_pr$CaCarb)]<- 0

summary(dsp_pr$CaCarb)

# calculate SOC - soil organic carbon
SOC_calc <- dsp_pr$Tot_C - 0.11*dsp_pr$CaCarb


dsp_pr$SOC <- as.numeric(
    ifelse(!is.na(dsp_pr$Est_totOC), dsp_pr$Est_totOC,   
      ifelse(!is.na(dsp_pr$Tot_C), dsp_pr$Tot_C,                       
              ifelse(!is.na(dsp_pr$Total.C), dsp_pr$Total.C, 
               NA ))))
                
summary(dsp_pr$SOC)

dsp_pr$TN <- as.numeric(ifelse(!is.na(dsp_pr$Tot_N), dsp_pr$Tot_N, dsp_pr$Total.N))  
     
                
summary(dsp_pr$TN)

##comparable layer labels
comp_label <- data.frame(
  Comp_layer =c(1,2,3,4),
  comp_label = c(comp_1, comp_2, comp_3, comp_4))


# clean out columns for properties that were not measured
dsp_pro <- Filter( f=function(x) !all(is.na(x)), x=dsp_pr)

#join comparable layer labels, the sort by comparable layer (1,2 etc.)
require(plyr)
dsp_proj <- join(dsp_pro, comp_label, by="Comp_layer")

dsp_proj$comp_label <- with(dsp_proj, reorder(factor(dsp_proj$comp_label), dsp_proj$Comp_layer))

#reset facotrs to only levels found in this project
dsp_proj[,"Name"] <- factor(dsp_proj[,"Name"])
dsp_proj[,COMPARE] <- factor(dsp_proj[,COMPARE])
dsp_proj[,PLOT] <- factor(dsp_proj[,PLOT])
dsp_proj[,PLOT_NO] <- factor(dsp_proj[,PLOT_NO])
dsp_proj[,"Soil"] <- factor(dsp_proj[,"Soil"])
dsp_proj[,"Region.strata"] <- factor(dsp_proj[,"Region.strata"])

#see levels within project
dsp_proj <- droplevels(dsp_pr)
factors(dsp_proj$COND)


# honestly these can be done on-demand as they are needed for graphing/analysis
#subset by horizon master (A & B) and surface
dsp_1 <- dsp_proj[which(dsp_proj$Hor_sequ==1),]
dsp_A <-  dsp_proj[which(grepl("^A", dsp_proj$hor_desg)),]
dsp_B <-  dsp_proj[which(grepl("^B", dsp_proj$hor_desg)),]

```

## SUMMARY PLOTS
```{r summaryPlot}
###define funtion to create summary plots
dsp1_box<- function(df=dsp_1, compare=COMPARE, p=PLOT, n=PLOT_NO, xlab=x_label, lbl=dsp_labels, start_column=29){
  require(RColorBrewer)
  require(ggplot2)
  dfx <- factor(df[,compare])
  ln <- length(names(df))
  proj <- as.character(df[1,"DSP.Project"])
  y <- df[,start_column]
  c<-factor(df[,n])
  nc<-nlevels(c)

  namey <- as.character(lbl[grepl(names(df[start_column]), lbl[,"Anal"]), "Label"])
    
  Q <- qplot(x=dfx, y=y, data=df, color=c, main=proj, xlab = x_label,
             ylab = namey, geom="boxplot")
  
  myColors <- if (nc<3) c("blue", "red") else (brewer.pal(nc,"Set1"))
  names(myColors) <- levels(c)
  colScale <- scale_colour_manual(name = "PLOT",values = myColors)
  Qi <- Q +colScale
  Qi
}

# test box-plot function - column number 29 (currently aggregate stability)
dsp1_box(dsp_1 , COMPARE, PLOT, PLOT_NO, x_label, dsp_labels, start_column=fmatch(A,names(dsp_1)))
```

#####Function to put multiple ggplots on one page - titles need work
``` {r defineMultiplot, echo=FALSE}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```



#### Individual plots for prop of interest
```{r propPlot, error=T}
#displays properties of interest defined above
require(fastmatch)
propA_surf_box<- dsp1_box(dsp_1 , COMPARE, PLOT, PLOT_NO, x_label, dsp_labels, start_column=fmatch(A,names(dsp_1)))
propB_surf_box<- dsp1_box(dsp_1 , COMPARE, PLOT, PLOT_NO, x_label, dsp_labels, start_column=fmatch(B,names(dsp_1)))
propC_surf_box<- dsp1_box(dsp_1, COMPARE, PLOT, PLOT_NO, x_label, dsp_labels, start_column=fmatch(C,names(dsp_1)))
propD_surf_box<- dsp1_box(dsp_1, COMPARE, PLOT, PLOT_NO, x_label, dsp_labels, start_column=fmatch(D,names(dsp_1)))


print(propA_surf_box)
print(propB_surf_box)
print(propC_surf_box)
print(propD_surf_box)

multiplot(propA_surf_box, propB_surf_box, propC_surf_box, propD_surf_box, cols=2)

```

-------------------------------------------------------------------

### Create an output for all properties
Need to make sure only numeric property values are graphed


####First Layer - only a couple relevant properties
```{r}
#loop function over relevent columns for each subset
#### Surface horizon
filename <-paste0(out.loc,"Surface_", PROJECT,".pdf")
pdf(filename)
  print(dsp1_box(dsp_1, COMPARE, PLOT, PLOT_NO, x_label, lbl=dsp_labels, start_column=fmatch("SOC",names(dsp_1))))
  print(dsp1_box(dsp_1, COMPARE, PLOT, PLOT_NO, x_label, lbl=dsp_labels, start_column=fmatch("BulkDensity",names(dsp_1))))
  print(dsp1_box(dsp_1, COMPARE, PLOT, PLOT_NO, x_label, lbl=dsp_labels, start_column=fmatch("TN",names(dsp_1))))
dev.off()
```


*****************
## Aggregate over Pedons, comparable layers and Plots
```{r Aggregate}
numcomp <- sapply(dsp_proj, is.numeric)
datacomp<-data.frame(dsp_proj[,numcomp])

#mean for each pedon (average comparable layers)
mean_ped_comp <-aggregate(x = datacomp, by = list(comp_layer = dsp_proj$Comp_layer, UserPedonID = dsp_proj$UserPedonID, COND = dsp_proj[,COMPARE], Plot.ID = dsp_proj[,PLOT], Pedon_ID = dsp_proj$Pedon_ID), mean, na.rm=T)
sd_ped_comp <-aggregate(x = datacomp, by = list(comp_layer = dsp_proj$Comp_layer, UserPedonID = dsp_proj$UserPedonID, COND = dsp_proj[,COMPARE], Plot.ID = dsp_proj[,PLOT], Pedon_ID = dsp_proj$Pedon_ID), sd, na.rm=T)
mean_ped_comp$stat <- "pedmean"
sd_ped_comp$stat <- "pedsd"                                  

dsp_ped_comp <- rbind(mean_ped_comp, sd_ped_comp[-1,])

colout <- "Hor_sequ"

dsp_ped_compl <- join(dsp_ped_comp, comp_label, by="Comp_layer")


write.csv(dsp_ped_compl[,!(names(dsp_ped_compl) %in% colout)], file = paste0(out.loc,PROJECT, "_comp-layer_byPED.csv"), row.names=F)

#Aggregate by plot for each comparable layer
numcompl <- sapply(dsp_ped_compl, is.numeric)

mean_plot_comp <- aggregate(x = mean_ped_comp[,numcompl], by = list(comp_layer = mean_ped_comp$comp_layer, COND = mean_ped_comp$COND, plot_id = mean_ped_comp$plot_id), mean, na.rm=T)
sd_plot_comp <-aggregate(x = sd_ped_comp[,numcompl], by = list(comp_layer = sd_ped_comp$comp_layer, COND = sd_ped_comp$COND,plot_id = sd_ped_comp$plot_id), sd, na.rm=T)
mean_plot_comp$stat <- "plotmean"
sd_plot_comp$stat <- "plotsd" 


dsp_plot_comp <- rbind( mean_plot_comp, sd_plot_comp[-1,])

colout <- c("Plot", "Pedon", "Hor_sequ")

dsp_plot_compl <- join(dsp_plot_comp, comp_label, by="Comp_layer")

# write table of aggregated plot data to output folder

write.csv(dsp_plot_compl[,!(names(dsp_plot_compl) %in% colout)], file = paste0(out.loc,PROJECT, "_comp-layer_byPLOT.csv"), row.names=F)



### subset by comparable layer

dsp_c1 <- dsp_ped_compl[dsp_ped_compl$Comp_layer==1 & dsp_ped_compl$stat=="pedmean",]
dsp_c2 <- dsp_ped_compl[dsp_ped_compl$Comp_layer==2 & dsp_ped_compl$stat=="pedmean",]
dsp_c3 <- dsp_ped_compl[dsp_ped_compl$Comp_layer==3 & dsp_ped_compl$stat=="pedmean",]
dsp_c4 <- dsp_ped_compl[dsp_ped_compl$Comp_layer==4 & dsp_ped_compl$stat=="pedmean",]

dsp_ped <-dsp_ped_compl[dsp_ped_compl$stat=="pedmean",]

```


####Comparable layer #1
```{r}
#loop function over relevent columns for each subset
#### Surface horizon
filename <-paste0(out.loc,"CompLayer1_", PROJECT,".pdf")
pdf(filename)
ln <- length(names(dsp_c1))-2
for(i in 29:ln){
  print(dsp1_box(dsp_c1, COMPARE, PLOT, PLOT_NO, x_label, lbl=dsp_labels, start_column=i) )
}
dev.off()
```

### Boxplots of comparable layers

## function to create boxplots for all samples by comparable layer
```{r Comparabl_plot}
dsp_comp_box<- function(df=dsp_ped, compare=COMPARE, p=PLOT, n=PLOT_NO, xlab=x_label, lbl=dsp_labels, proj=PROJECT, start_column=29){
    
    y <- names(df)[start_column]  
    namey <- as.character(lbl[grepl(names(df[start_column]), lbl[,"Anal"]), "Label"])
  
  
Qcomp <- ggplot(data=df, aes_string(x=compare, y=y)) + ylab(namey) + xlab("All Horizons") + ggtitle(paste0(proj, " All Horizons")) + geom_boxplot() 

    Qc<- Qcomp + geom_jitter(data=df, aes_string(x=compare, y=y, colour= p), show_guide=T)
    Qf <- Qc + facet_wrap(~comp_label)
    Q <- Qf 
  print(Q)
}

# test dsp_comp_box function

dsp_comp_box(df=dsp_ped, compare=COMPARE, p=PLOT, n=PLOT_NO, xlab=x_label, lbl=dsp_labels, proj=PROJECT, start_column=65)
```

### Loop over all properties
```{r}
filename <-paste0(out.loc,"AllCompLayer_", PROJECT,"_new.pdf")
pdf(filename)
ln <- length(names(dsp_proj))-2
for(i in 29:ln){
  print(dsp_comp_box(dsp_proj, COMPARE, PLOT, PLOT_NO, x_label, labels=dsp_labels, start_column=i) )
}
dev.off()
```

##O horizon thickness as variable
```{r Ohorizon}

#this only works if there is only one O horizon per pedon

Othick <- ifelse(grep("^O", dsp_1$hor_desg), dsp_1$hor_bottom, 0)

dsp_c1.O <- cbind(dsp_c1, Othick)

dsp1_box(dsp_c1.O, COMPARE, PLOT, PLOT_NO, x_label, lbl=dsp_labels, start_column=68)


df=dsp_c1.O
  dfx <- factor(df[,COMPARE])
  ln <- length(names(df))
  proj <- as.character(df[1,"DSP.Project"])
  y <- df[,start_column]
  c<-factor(df[,PLOT])
  nc<-nlevels(c)  

Q <- qplot(x=dfx, y=y, data=df, color=c, main=proj, xlab = x_label,
             ylab = namey, geom="boxplot")
  Q

  Qcomp <- ggplot(data=dsp_c1.O, aes(x=COND, y=Othick)) + ylab(namey)+ 
     geom_boxplot() +
    geom_boxplot(aes(group=Plot.ID, color = factor(Plot.ID)), alpha=0.5)
 Qcomp

```




##Aggregate Plots of overalll condition
```{r Aggregate_PLOTS}
##ped averages
# for sd initial
filename <-paste0(out.loc,"comp_new", PROJECT,"new.pdf")
pdf(filename)
for(i in 12:ln){
  m <- subset(dsp_ped_compl, stat=="pedmean")
  ln <- length(names(m))-3
    y <- names(m)[i]
    namey <- as.character(dsp_labels[grepl(y, dsp_labels$Anal), "Label"])
    proj <- as.character(dsp_proj[1,"Name"])
n <- PLOT

  
  
  Qcomp <- ggplot(data=m, aes_string(x="COND", y=y)) + ylab(namey)+ 
    xlab(" All Horizons") + ggtitle(paste0(proj, " by Pedon"))+ geom_boxplot() + 
    geom_boxplot(aes(group=Plot.ID, color = factor(Plot.ID)), alpha=0.5)    
Qcomp
  Q <- Qcomp + facet_wrap(~comp_label)                            
  
  
  print(Q)
}
#dev.off()
```

```{r density_plot}
# #density plot of mgmt systems
filename <-paste0(out.loc,"DensityPlots_", PROJECT,"_more.pdf")
pdf(filename)
# #################could loop across columns
  qplot(Tot_C, data=dsp_c1, geom="density", fill=COND, alpha=I(.25))
  qplot(Clay, data=dsp_c1, geom="density", fill=COND, alpha=I(.25))
  qplot(BulkDensity, data=dsp_c1, geom="density", fill=COND, alpha=I(.25))
  qplot(Bgluc, data=dsp_c1, geom="density", fill=COND, alpha=I(.25))
  qplot(AggStab, data=dsp_c1, geom="density", fill=COND, alpha=I(.25))

# #density plot by comparable layer
qplot(SOC, data=dsp_proj, geom="density", fill=comp_label, alpha=I(.5))
qplot(BulkDensity, data=dsp_proj, geom="density", fill=comp_label, alpha=I(.5))
qplot(AggStab, data=dsp_proj, geom="density", fill=comp_label, alpha=I(.5))
qplot(Clay, data=dsp_proj, geom="density", fill=comp_label, alpha=I(.5))

#density plot by Soil


qplot(SOC, data=dsp_proj, geom="density", fill=comp_label, alpha=I(.25), facets = . ~ COND )
qplot(Clay, data=dsp_proj, geom="density", fill=comp_label, alpha=I(.25), facets = . ~ COND)
qplot(BulkDensity, data=dsp_proj, geom="density", fill=comp_label, alpha=I(.25), facets = . ~ COND)
qplot(AggStab, data=dsp_proj, geom="density", fill=comp_label, alpha=I(.25), facets = . ~ COND)

  
# Density by Soil, Comparable Layer and Condition
qplot(SOC, data=dsp_proj, geom="density", fill=COND, alpha=I(.25), facets = comp_label ~ Soil)
qplot(Clay, data=dsp_proj, geom="density", fill=COND, alpha=I(.25), facets = comp_label ~ Soil)
qplot(BulkDensity, data=dsp_proj, geom="density", fill=COND, alpha=I(.25), facets = comp_label ~ Soil)
qplot(AggStab, data=dsp_proj, geom="density", fill=COND, alpha=I(.25), facets = .~ Soil)

dev.off()
```

# DATA ANAL

## ANal for surface horizon
```{r}
#flag numberic data columns into seperate dataframe
nums <- sapply(dsp_1, is.numeric)
data1<-data.frame(dsp_1[,nums])

#overall by plot -  mean, sd, max and min
min_plot_1 <- aggregate(x=data1, by = list(COND = dsp_1[,COMPARE],plot_id = dsp_1[,PLOT]), min, na.rm=T)
max_plot_1 <- aggregate(x = data1, by = list(COND = dsp_1[,COMPARE],plot_id = dsp_1[,PLOT]), max, na.rm=T)
mean_plot_1 <-aggregate(x = data1, by = list(COND = dsp_1[,COMPARE],plot_id = dsp_1[,PLOT]), mean, na.rm=T)
sd_plot_1 <-aggregate(x = data1, by = list(COND = dsp_1[,COMPARE],plot_id = dsp_1[,PLOT]), sd, na.rm=T)

#add label column - within plot variables
min_plot_1$stat <- "pedmin"
max_plot_1$stat <- "pedmax"
mean_plot_1$stat <- "plotmean"
sd_plot_1$stat <- "plotsd"

dsp_plot_surf <- rbind(min_plot_1, max_plot_1[-1,], mean_plot_1[-1,], sd_plot_1[-1,])

#get rid of columns that no longer make sense
colout <- c("Plot", "Pedon", "pedonID", "Hor_sequ")

#write table to a csv, that can be opened by excel, in designated output folder
write.csv(dsp_plot_surf[,!(names(dsp_plot_surf) %in% colout)], file = paste0(out.loc,PROJECT, "_surface_byPLOT.csv"), row.names=F)


#summary for cond (mgmt systems or state phases)

# get numeric columns for plot data
numstat <- sapply(dsp_plot_surf, is.numeric)

#Get min for the lowest pedon value (min_indivped) and the lowest plot avg (min_plot_avg)
min_cond_1 <- aggregate(x=min_plot_1[,numstat], by = list(COND = min_plot_1$COND), min, na.rm=T)
min_plotavg_1 <- aggregate(x=mean_plot_1[,numstat], by = list(COND = mean_plot_1$COND), min, na.rm=T)
min_cond_1$stat <- "min_indivped"
min_plotavg_1$stat<- "min_plotavg"

max_cond_1 <-  aggregate(x=max_plot_1[,numstat], by = list(COND = max_plot_1$COND), max, na.rm=T)
max_plotavg_1 <- aggregate(x=mean_plot_1[,numstat], by = list(COND = mean_plot_1$COND), max, na.rm=T)
max_cond_1$stat <- "max_indivped"
max_plotavg_1$stat<- "max_plotavg"

mean_cond_1 <-  aggregate(x=mean_plot_1[,numstat], by = list(COND = mean_plot_1$COND), mean, na.rm=T)
mean_cond_1$stat <- "cond_mean"

sd_plot_mean1 <-  aggregate(x=sd_plot_1[,numstat], by = list(COND = sd_plot_1$COND), mean, na.rm=T)
sd_plot_min1 <-  aggregate(x=sd_plot_1[,numstat], by = list(COND = sd_plot_1$COND), min, na.rm=T)
sd_plot_max1 <- aggregate(x=sd_plot_1[,numstat], by = list(COND = sd_plot_1$COND), max, na.rm=T)
sd_plot_mean1$stat <- "sd_plot_mean"
sd_plot_min1$stat <- "sd_plot_min"
sd_plot_max1$stat <- "sd_plot_max"

sd_cond_1 <-  aggregate(x=mean_plot_1[,numstat], by = list(COND = mean_plot_1$COND), sd, na.rm=T)
sd_cond_1$stat <- "cond_sd"

dsp_cond_surf <-  rbind(min_cond_1, min_plotavg_1[-1,], max_cond_1[-1,], max_plotavg_1[-1,], mean_cond_1[-1,],
                        sd_plot_mean1[-1,], sd_plot_min1[-1,], sd_plot_max1[-1,], sd_cond_1[-1,])


#write table to a csv, that can be opened by excel, in designated output folder
write.csv(dsp_cond_surf[,!(names(dsp_cond_surf) %in% colout)], file = paste0(out.loc,PROJECT, "_surface_byCOND.csv"), row.names=F)


##ANal by Comparable Layers

#flag numberic data columns into seperate dataframe
numcomp <- sapply(dsp_proj, is.numeric)
datacomp<-data.frame(dsp_proj[,numcomp])

#overall by plot -  mean, sd, max and min

min_plot_comp <- aggregate(x = datacomp, by = list(comp_layer = dsp_proj$Comp_layer, COND = dsp_proj[,COMPARE],plot_id = dsp_proj[,PLOT]), min, na.rm=T)
max_plot_comp <- aggregate(x = datacomp, by = list(comp_layer = dsp_proj$Comp_layer, COND = dsp_proj[,COMPARE],plot_id = dsp_proj[,PLOT]), max, na.rm=T)
mean_plot_comp <-aggregate(x = datacomp, by = list(comp_layer = dsp_proj$Comp_layer, COND = dsp_proj[,COMPARE],plot_id = dsp_proj[,PLOT]), mean, na.rm=T)
sd_plot_comp <-aggregate(x = datacomp, by = list(comp_layer = dsp_proj$Comp_layer, COND = dsp_proj[,COMPARE],plot_id = dsp_proj[,PLOT]), sd, na.rm=T)

#add label column - within plot variables
min_plot_comp$stat <- "pedmin"
max_plot_comp$stat <- "pedmax"
mean_plot_comp$stat <- "plotmean"
sd_plot_comp$stat <- "plotsd"

dsp_plot_comp <- rbind(min_plot_comp, max_plot_comp[-1,], mean_plot_comp[-1,], sd_plot_comp[-1,])

#get rid of columns that no longer make sense
colout <- c("Plot", "Pedon", "pedonID", "Hor_sequ")

#put comparable layer labels back on
dsp_plot_compl <- join(dsp_plot_comp, comp_label, by="Comp_layer")

#write table to a csv, that can be opened by excel, in designated output folder
write.csv(dsp_plot_compl[,!(names(dsp_plot_compl) %in% colout)], file = paste0(out.loc,PROJECT, "_comp-layer_byPLOT.csv"), row.names=F)


#summary for cond (mgmt systems or state phases)
# get numeric columns for plot data

numcompl <- sapply(dsp_plot_compl, is.numeric)

#Get min for the lowest pedon value (min_indivped) and the lowest plot avg (min_plot_avg)
min_cond_comp <- aggregate(x=min_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = min_plot_comp$COND), min, na.rm=T)
min_plotavg_comp <- aggregate(x=mean_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = mean_plot_comp$COND), min, na.rm=T)
min_cond_comp$stat <- "min_indivped"
min_plotavg_comp$stat<- "min_plotavg"

max_cond_comp <-  aggregate(x=max_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = max_plot_comp$COND), max, na.rm=T)
max_plotavg_comp <- aggregate(x=mean_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = mean_plot_comp$COND), max, na.rm=T)
max_cond_comp$stat <- "max_indivped"
max_plotavg_comp$stat<- "max_plotavg"

mean_cond_comp <-  aggregate(x=mean_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = mean_plot_comp$COND), mean, na.rm=T)
mean_cond_comp$stat <- "cond_mean"

sd_plot_meancomp <-  aggregate(x=sd_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = sd_plot_comp$COND), mean, na.rm=T)
sd_plot_mincomp <-  aggregate(x=sd_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = sd_plot_comp$COND), min, na.rm=T)
sd_plot_maxcomp <- aggregate(x=sd_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = sd_plot_comp$COND), max, na.rm=T)
sd_plot_meancomp$stat <- "sd_plot_mean"
sd_plot_mincomp$stat <- "sd_plot_min"
sd_plot_maxcomp$stat <- "sd_plot_max"

sd_cond_comp <-  aggregate(x=mean_plot_comp[,numcompl], by = list(comp_layer = min_plot_comp$comp_layer, COND = mean_plot_comp$COND), sd, na.rm=T)
sd_cond_comp$stat <- "cond_sd"

dsp_cond_comp <-  rbind(min_cond_comp, min_plotavg_comp[-1,], max_cond_comp[-1,], max_plotavg_comp[-1,], mean_cond_comp[-1,],
                        sd_plot_meancomp[-1,], sd_plot_mincomp[-1,], sd_plot_maxcomp[-1,], sd_cond_comp[-1,])

dsp_cond_compl <- join(dsp_plot_comp, comp_label, by="Comp_layer")

colout <- c("Plot", "Pedon", "pedonID", "Hor_sequ")

#write table to a csv, that can be opened by excel, in designated output folder
write.csv(dsp_cond_compl[,!(names(dsp_cond_compl) %in% colout)], file = paste0(out.loc,PROJECT, "_comp-layer_byCOND.csv"), row.names=F)
```

**********************

## Mixed Model
###test for the effect of conditions on soil properties
```{r}
require(lme4)

#function to test COMPARE condition - uses mixed model to fit two models one with and without COMPARE
#then uses anova to test for difference between models
cond_test <- function(df=dsp_1, COMPARE=COMPARE, PLOT=PLOT, LABELS=dsp_labels, start_col=29){
  require(lme4)
  C <- factor(df[,COMPARE])
  P <- factor(df[,PLOT])
  
  prop <- as.character(labels[grepl(names(df)[start_col], labels[,"Anal"]), "Label"]
  xx <- df[,start_col]
  
  fit_cond_i <- lmer(xx ~  C + (1|P) , data=df, REML= F)
  fit_r_i <- lmer(df[,start_col] ~ (1|P), data=df, REML=F)
  a_i <- anova(fit_r_i, fit_cond_i)
  p <- as.numeric(a_i[2,8])
  pl_i <- cbind(prop, p)
  pl_i
}


#test function
cond_test(df=dsp_proj, COMPARE=COMPARE, PLOT=PLOT, LABELS=dsp_labels, start_col=29)

#This creates a csv file with an F test for the statistical difference between levels of COMPARE (mgmt system or condition)



for(i in 29:ln){
  ln <- length(names(dsp_1))-1
    
  pl_i <- tryCatch(cond_test(df=dsp_1, COMPARE=COMPARE, PLOT=PLOT, LABELS=dsp_labels, start_col=i), error=function(e) NULL) 
    if (i ==29)
  {
    write.table(pl_i, file = paste0(out.loc, PROJECT,"_surface_ftest.csv"), sep = ",", col.names = c("Property", "p value"), row.names=F )
  } else
  {
    write.table(pl_i, file = paste0(out.loc, PROJECT,"_surface_ftest.csv"), sep = ",", append = T, row.names = F, col.names=F);
  }
}

# do by COND for each comparable layer
# #Comparable layers
#uncomment c3 and c4 if there are more than 2 comparable layers


for(i in 25:ln){
  ln <- length(names(dsp_c1))-1
  
  #comparable layer 1 and 2
  
  t1 <- tryCatch(cond_test(df=dsp_c1, COMPARE=COMPARE, PLOT=PLOT, labels=dsp_labels, start_col=i), error=function(e) NULL) 
  t2 <- tryCatch(cond_test(df=dsp_c2, COMPARE=COMPARE, PLOT=PLOT, labels=dsp_labels, start_col=i), error=function(e) NULL)
  
  
  pl_c1 <- if (!is.null(t1))
  {cbind(as.character(comp_1),t1)
  } else
  { cbind(as.character(comp_1),as.character(dsp_labels[i,"Label"]),"NULL") }
  pl_c2 <- if (!is.null(t2)){
    cbind(as.character(comp_2),t2)
  } else
  {cbind(as.character(comp_2), as.character(dsp_labels[i, "Label"]), "NULL")}
  
  d1<- data.frame(pl_c1)
  names(d1) <-  c("Comparable Layer", "Property", "p-value")
  d2<- data.frame(pl_c2)
  names(d2) <-  c("Comparable Layer", "Property", "p-value") 
  
  pl_i <- rbind.fill(d1, d2)  
#   
#   
#   #comparable layer 3 and 4 - you can uncomment to include
#   # if one of these is blank - it will create many extra rows in the final tabel (with blanks for comparable layer)
#   #    t3 <- fs_cond_test(df=test_proj_c3, COMPARE=COMPARE, PLOT=PLOT, dsp_labels=dsp_labels, start_col=i)
#   #    t4 <- fs_cond_test(df=test_proj_c4, COMPARE=COMPARE, PLOT=PLOT, dsp_labels=dsp_labels, start_col=i)
#   #   
#   #    pl_c3 <- if (!is.null(t3)){
#   #       cbind(as.character(comp_label[1,3]),t3)
#   #       } else
#   #         {cbind(as.character(comp_3),as.character(dsp_labels[i, "Label"]),"NULL" ) }
#   #    pl_c4 <- if (!is.null(t4)){
#   #      cbind(as.character(comp_4),t4)
#   #    } else
#   #         {cbind(as.character(comp_4), as.character(dsp_labels[i, "Label"]), "NULL")}
#   #   
#   #       d3<- data.frame(pl_c3)
#   #       names(d3) <-  c("Comparable Layer", "Property", "p-value")
#   #       d4<- data.frame(pl_c4)
#   #       names(d4) <-  c("Comparable Layer", "Property", "p-value")  
#   #   
#   #   
#   #    pl_i <- rbind.fill(d1, d2, d3, d4)  
#   
#   
  if (i ==29)
  {
    write.table(pl_i, file = paste0(out.loc, PROJECT,"_comp_ftest.csv"), sep = ",", col.names = c("Comparable Layer", "Property", "p value"), row.names=F)
  } else
  {
    write.table(pl_i, file = paste0(out.loc, PROJECT,"_comp_ftest.csv"), sep = ",", append = T, row.names = F, col.names=F)
  }
}
# 
# 
#
# 
# # get covariance estimates

get_cov <- function(df=dsp_1, PL=PLOT, start_col=29, labels=dsp_labels){
  prop1<- as.character(labels[grepl(names(df)[start_col], labels[,"Anal"]), "Label"])
  P <- factor(df[,PL])
  fit_cov <- lmer(df[,start_col] ~ (1|P), data=df, REML=T)
  cov <- as.data.frame(VarCorr(fit_cov))
  COV1 <- cbind(prop1, ex$vcov[1],ex$vcov[2])
  COV1
  
}


#test_covariance output
covs <- get_cov()
covs_i <- by(data=dsp_1, factor(dsp_1[,COMPARE]), get_cov, start_col=39)
v1 <- data.frame(cbind(names(covs_i)[[1]],covs_i[[1]]))
v2 <- cbind(names(covs_i)[[2]],covs_i[[2]])
tab_i <- rbind(v1,v2)
#
#

covs_by <- function(sc=30){
  cb <-  by(data=test_1, factor(test_1$COMPARE), get_cov, start_col=sc)
  # trying to make more general
  # cb<- by(data=d, factor(print(ind)), get_cov, df=d, start_col=sc)
  cb
}

# try_cb <- tryCatch(covs_by(sc=31), error = fuction(e) e, NULL)
#
# fw_covs <- failwith(NULL, covs_by)        
#
# if(inherits(try_cb, "error"){
#                    message("Caught error:", try_cb$message)           
#                      ## error reading..
#                    } else{
#                      covs_i
#                    }
#  
#
# start_col <- 31
# prop<- as.character(labels[start_col, "Label"])
# prop


for(i in 25:ln){
  ln <- length(names(test_1))-3
  t <- aggregate(test_1[,i]~test_1$COMPARE, data=test_1, mean)
  
  if ((t[1,2]==0) & (t[2,2]==0)){
    
    v1 <- cbind(paste(t[1,1]),as.character(dsp_labels[i,"Label"]),"NULL", "NULL")
    v2 <- cbind(paste(t[2,1]),as.character(dsp_labels[i,"Label"]),"NULL", "NULL")
    
  } else
    if(t[1,2]==0){
      
      v1 <- cbind(paste(t[1,1]),as.character(dsp_labels[i,"Label"]),"NULL", "NULL")
      
      covs_i <- get_cov(start_col=i)
      v2 <- cbind(paste(t[2,1]),covs_i)
      
    } else
      if(t[2,2]==0){
        covs_i <- get_cov(start_col=i)
        v1 <- cbind(paste(t[1,1]), covs_i)
        v2 <- cbind(paste(t[2,1]),as.character(dsp_labels[i,"Label"]),"NULL", "NULL")
        
      } else {
        covs_i <- covs_by(sc=i)
        v1 <- cbind(names(covs_i)[[1]],covs_i[[1]])
        v2 <- cbind(names(covs_i)[[2]],covs_i[[2]])
        
      }
  
  
  tab_i <- rbind(v1,v2)
  
  ## handling for more than two conditions needs to be added
  
  if (i==29)
  {
    write.table(tab_i, file = paste0(out.loc, PROJECT,"_surface_covariance.csv"), sep = ",", col.names = c(COMPARE, "Property", "Plot var", "Residual var"), row.names=F )
  } else
  {
    write.table(tab_i, file = paste0(out.loc, PROJECT,"_surface_covariance.csv"), sep = ",", append = T, row.names = F, col.names=F)
  }
  
}

